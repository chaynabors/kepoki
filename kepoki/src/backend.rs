use std::borrow::Cow;

use serde::Deserialize;
use serde::Serialize;

use crate::error::KepokiError;

#[derive(Clone, Debug)]
pub struct Tool<'a> {
    /// Name of the tool.
    pub name: Cow<'a, str>,
    /// JSON schema for this tool's input.
    pub input_schema: Option<Cow<'a, str>>,
    /// Description of what this tool does.
    pub description: Option<Cow<'a, str>>,
}

#[derive(Clone, Copy, Debug, Deserialize, Serialize)]
pub enum Role {
    User,
    Assistant,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum ContentBlock {
    Text {
        text: String,
    },
    Image {
        source: ImageSource,
    },
    ToolUse {
        id: String,
        input: String,
        name: String,
    },
    ToolResult {
        tool_use_id: String,
        content: Option<Vec<ToolResultContentBlock>>,
        is_error: Option<bool>,
    },
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum ContentBlockDelta {
    Text { id: String, text: String },
    InputJson { id: String, partial_json: String },
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ContentBlockStop {
    pub index: usize,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ContentBlockStart {
    pub index: usize,
    pub content_block: ContentBlock,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum ToolResultContentBlock {
    Text { text: String },
    Image { source: ImageSource },
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum ImageSource {
    Base64 {
        data: String,
        media_type: ImageMediaType,
    },
}

#[derive(Clone, Copy, Debug, Deserialize, Serialize)]
pub enum ImageMediaType {
    Jpeg,
    Png,
    Gif,
    Webp,
}

#[derive(Clone, Debug)]
pub enum ToolChoice {
    Auto {
        /// Whether to disable parallel tool use.
        disable_parallel_tool_use: bool,
    },
    Any {
        /// Whether to disable parallel tool use.
        disable_parallel_tool_use: bool,
    },
    Tool {
        /// The name of the tool to use.
        tool_name: String,
        /// Whether to disable parallel tool use.
        disable_parallel_tool_use: bool,
    },
}

#[derive(Clone, Debug)]
pub struct ApiError {
    pub error: ApiErrorDetails,
}

#[derive(Clone, Debug)]
pub struct ApiErrorDetails {
    pub r#type: String,
    pub message: String,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct InputMessage {
    pub role: Role,
    pub content: Vec<ContentBlock>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Message {
    /// Unique object identifier.
    id: String,
    /// Content generated by the model.
    content: Vec<ContentBlock>,
    /// The reason that we stopped.
    stop_reason: Option<StopReason>,
    /// Which custom stop sequence was generated, if any.
    stop_sequence: Option<String>,
    /// Billing and rate-limit usage.
    usage: Option<Usage>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MessageDelta {
    /// The reason that we stopped.
    stop_reason: Option<StopReason>,
    /// Which custom stop sequence was generated, if any.
    stop_sequence: Option<String>,
    /// Billing and rate-limit usage.
    usage: Option<Usage>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Usage {
    input_tokens: u32,
    output_tokens: u32,
}

pub struct MessagesRequest<'a, B: Backend> {
    /// The model to use for this request.
    pub model: B::Model,
    /// Input messages.
    pub messages: Vec<InputMessage>,
    /// The maximum number of tokens to generate before stopping.
    pub max_tokens: u32,
    /// System prompt.
    pub system: Option<Cow<'a, str>>,
    /// Amount of randomness injected into the response.
    pub temperature: Option<f32>,
    /// How the model should use the provided tools.
    pub tool_choice: Option<ToolChoice>,
    /// Definitions of tools that the model may use.
    pub tools: Option<Vec<Tool<'a>>>,
}

#[derive(Clone, Copy, Debug, Deserialize, Serialize)]
pub enum StopReason {
    /// The model reached a natural stopping point
    EndTurn,
    /// We exceeded the requested max_tokens or the model's maximum
    MaxTokens,
    /// One of your provided custom stop_sequences was generated
    StopSequence,
    /// The model invoked one or more tools
    ToolUse,
    /// We paused a long-running turn. You may provide the response back as-is in a subsequent request to let the model continue.
    PauseTurn,
    /// When streaming classifiers intervene to handle potential policy violations
    Refusal,
}

#[derive(Clone, Debug)]
pub enum MessagesResponseEvent {
    Ping,
    MessageStart(Message),
    MessageDelta(MessageDelta),
    MessageStop,
    ContentBlockStart(ContentBlockStart),
    ContentBlockDelta(ContentBlockDelta),
    ContentBlockStop(ContentBlockStop),
}

pub trait MessageStream: Send + 'static {
    fn recv(&mut self) -> Result<Option<MessagesResponseEvent>, KepokiError>;
}

pub trait Backend: Sized + Send + 'static {
    type Model: Clone + Send + 'static;
    type MessagesEventStream: MessageStream;

    fn messages(
        &self,
        request: MessagesRequest<Self>,
    ) -> Result<Self::MessagesEventStream, KepokiError>;
}
